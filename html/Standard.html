<HTML>
<HEAD>
<TITLE>Standard.pm</TITLE>
<LINK REL="stylesheet" HREF="../html/docs.css" TYPE="text/css">
<LINK REV="made" HREF="mailto:">
</HEAD>

<BODY>
<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH=100%>
<TR><TD CLASS=block VALIGN=MIDDLE WIDTH=100% BGCOLOR="#cccccc">
<FONT SIZE=+1><STRONG><P CLASS=block>&nbsp;Standard.pm</P></STRONG></FONT>
</TD></TR>
</TABLE>

<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

    <UL>

        <LI><A HREF="#name">NAME</A></LI>
        <LI><A HREF="#synopsis">SYNOPSIS</A></LI>
        <LI><A HREF="#description">DESCRIPTION</A></LI>
        <UL>

            <LI><A HREF="#autoloading">Autoloading</A></LI>
            <LI><A HREF="#specified export">Specified Export</A></LI>
            <LI><A HREF="#mix and match">Mix and Match</A></LI>
        </UL>

        <LI><A HREF="#$post_max and $disable_uploads">$POST_MAX and $DISABLE_UPLOADS</A></LI>
        <LI><A HREF="#export">EXPORT</A></LI>
        <LI><A HREF="#function details">FUNCTION DETAILS</A></LI>
        <LI><A HREF="#bugs">BUGS</A></LI>
        <LI><A HREF="#author">AUTHOR</A></LI>
        <LI><A HREF="#credits">CREDITS</A></LI>
        <LI><A HREF="#see also">SEE ALSO</A></LI>
    </UL>

</UL>
<!-- INDEX END -->

<HR>
<P>
<H2><A NAME="name">NAME</A></H2>
<P>CGI::Simple::Standard - a wrapper module for CGI::Simple that provides a
function style interface</P>
<P>
<H2><A NAME="synopsis">SYNOPSIS</A></H2>
<PRE>
    use CGI::Simple::Standard qw( -autoload );
    use CGI::Simple::Standard qw( :core :cookie :header :misc );
    use CGI::Simple::Standard qw( param upload );</PRE>
<PRE>
    $CGI::Simple::Standard::POST_MAX = 1024;       # max upload via post 1kB
    $CGI::Simple::Standard::DISABLE_UPLOADS = 0;   # enable uploads</PRE>
<PRE>
    @params = param();        # return all param names as a list
    $value =  param('foo');   # return the first value supplied for 'foo'
    @values = param('foo');   # return all values supplied for foo</PRE>
<PRE>
    %fields   = Vars();       # returns untied key value pair hash
    $hash_ref = Vars();       # or as a hash ref
    %fields   = Vars(&quot;|&quot;);    # packs multiple values with &quot;|&quot; rather than &quot;\0&quot;;</PRE>
<PRE>
    @keywords = keywords();   # return all keywords as a list</PRE>
<PRE>
    param( 'foo', 'some', 'new', 'values' );        # set new 'foo' values
    param( -name=&gt;'foo', -value=&gt;'bar' );
    param( -name=&gt;'foo', -value=&gt;['bar','baz'] );</PRE>
<PRE>
    append( -name=&gt;'foo', -value=&gt;'bar' );          # append values to 'foo'
    append( -name=&gt;'foo', -value=&gt;['some', 'new', 'values'] );</PRE>
<PRE>
    Delete('foo');   # delete param 'foo' and all its values
    Delete_all();    # delete everything</PRE>
<PRE>
    &lt;INPUT TYPE=&quot;file&quot; NAME=&quot;upload_file&quot; SIZE=&quot;42&quot;&gt;</PRE>
<PRE>
    $files    = upload()                   # number of files uploaded
    @files    = upload();                  # names of all uploaded files
    $filename = param('upload_file')       # filename of 'upload_file' field
    $mime     = upload_info($filename,'mime'); # MIME type of uploaded file
    $size     = upload_info($filename,'size'); # size of uploaded file</PRE>
<PRE>
    my $fh = $q-&gt;upload($filename);     # open filehandle to read from
    while ( read( $fh, $buffer, 1024 ) ) { ... }</PRE>
<PRE>
    # short and sweet upload
    $ok = upload( param('upload_file'), '/path/to/write/file.name' );
    print &quot;Uploaded &quot;.param('upload_file').&quot; and wrote it OK!&quot; if $ok;</PRE>
<PRE>
    $decoded    = url_decode($encoded);
    $encoded    = url_encode($unencoded);
    $escaped    = escapeHTML('&lt;&gt;&quot;&amp;');
    $unescaped  = unescapeHTML('&amp;lt;&amp;gt;&amp;quot;&amp;amp;');</PRE>
<PRE>
    $qs = query_string();   # get all data in $q as a query string OK for GET</PRE>
<PRE>
    no_cache(1);            # set Pragma: no-cache + expires
    print header();         # print a simple header
    # get a complex header
    $header = header(   -type       =&gt; 'image/gif'
                        -nph        =&gt; 1,
                        -status     =&gt; '402 Payment required',
                        -expires    =&gt;'+24h',
                        -cookie     =&gt; $cookie,
                        -charset    =&gt; 'utf-7',
                        -attachment =&gt; 'foo.gif',
                        -Cost       =&gt; '$2.00');</PRE>
<PRE>
    @cookies = cookie();        # get names of all available cookies
    $value   = cookie('foo')    # get first value of cookie 'foo'
    @value   = cookie('foo')    # get all values of cookie 'foo'
    # get a cookie formatted for header() method
    $cookie  = cookie(  -name    =&gt; 'Password',
                        -values  =&gt; ['superuser','god','my dog woofie'],
                        -expires =&gt; '+3d',
                        -domain  =&gt; '.nowhere.com',
                        -path    =&gt; '/cgi-bin/database',
                        -secure  =&gt; 1 );
    print header( -cookie=&gt;$cookie );       # set cookie</PRE>
<PRE>
    print redirect('<A HREF="http://go.away.now">http://go.away.now</A>');   # print a redirect header</PRE>
<PRE>
    dienice( cgi_error() ) if cgi_error();</PRE>
<P>
<H2><A NAME="description">DESCRIPTION</A></H2>
<P>This module is a wrapper for the completely object oriented CGI::Simple
module and provides a simple functional style interface. It provides two
different methods to import function names into your namespace.</P>
<P>
<H3><A NAME="autoloading">Autoloading</A></H3>
<P>If you specify the '-autoload' pragma like this:</P>
<PRE>
    use CGI::Simple::Standard qw( -autoload );</PRE>
<P>Then it will use AUTOLOAD and a symbol table trick to export only those subs
you actually call into your namespace. When you specify the '-autoload' pragma
this module exports a single AUTOLOAD subroutine into you namespace. This will
clash with any AUTOLOAD sub that exists in the calling namespace so if you are
using AUTOLOAD for something else don't use this pragma.</P>
<P>Anyway, when you call a subroutine that is not defined in your script this
AUTOLOAD sub will be called. The first time this happens it
will initialize a CGI::Simple object and then apply the requested method
(if it exists) to it. A fatal exception will be thrown if you try to use an
undefined method (function).</P>
<P>
<H3><A NAME="specified export">Specified Export</A></H3>
<P>Alternatively you can specify the functions you wish to import. You can do
this on a per function basis like this:</P>
<PRE>
    use CGI::Simple::Standard qw( param upload query_string Dump );</PRE>
<P>or utilize the %EXPORT_TAGS that group functions into related groups.
Here are the groupings:</P>
<PRE>
  %EXPORT_TAGS = (
    ':html'     =&gt; [ qw(:misc) ],
    ':standard' =&gt; [ qw(:core :access) ],
    ':cgi'      =&gt; [ qw(:core :access) ],
    ':all'      =&gt; [ qw(:core :misc :cookie :header :push :debug :cgi-lib
                        :access :internal) ],
    ':core'     =&gt; [ qw(param add_param param_fetch url_param keywords
                        append Delete delete_all Delete_all upload
                        query_string parse_query_string  parse_keywordlist
                        Vars save_parameters restore_parameters) ],
    ':misc'     =&gt; [ qw(url_decode url_encode escapeHTML unescapeHTML put) ],
    ':cookie'   =&gt; [ qw(cookie raw_cookie) ],
    ':header'   =&gt; [ qw(header cache no_cache redirect) ],
    ':push'     =&gt; [ qw(multipart_init multipart_start multipart_end
                        multipart_final) ],
    ':debug'    =&gt; [ qw(Dump as_string cgi_error _cgi_object) ],
    ':cgi-lib'  =&gt; [ qw(ReadParse SplitParam MethGet MethPost MyBaseUrl MyURL
                        MyFullUrl PrintHeader HtmlTop HtmlBot PrintVariables
                        PrintEnv CgiDie CgiError Vars) ],
    ':ssl'      =&gt; [ qw(https) ],
    ':access'   =&gt; [ qw(version nph all_parameters charset crlf globals
                        auth_type content_length content_type document_root
                        gateway_interface path_translated referer remote_addr
                        remote_host remote_ident remote_user request_method
                        script_name server_name server_port server_protocol
                        server_software user_name user_agent virtual_host
                        path_info Accept http https protocol url self_url
                        state) ],
    ':internal' =&gt; [ qw(_initialize_globals _use_cgi_pm_global_settings
                        _store_globals _reset_globals) ]
    );</PRE>
<P>The familiar CGI.pm tags are available but do not include the HTML
functionality. You specify the import of some function groups like this:</P>
<P>use CGI::Simple::Standard qw( :core :cookie :header );</P>
<P>Note that the function groups all start with a : char.</P>
<P>
<H3><A NAME="mix and match">Mix and Match</A></H3>
<P>You can use the '-autoload' pragma, specifically named function imports and
tag group imports together if you desire.</P>
<P>
<H2><A NAME="$post_max and $disable_uploads">$POST_MAX and $DISABLE_UPLOADS</A></H2>
<P>If you wish to set $POST_MAX or $DISABLE_UPLOADS you must do this *after* the
use statement and *before* the first function call as shown in the synopsis.</P>
<P>Unlike CGI.pm uploads are disabled by default and the maximum acceptable
data via post is capped at 102_400kB rather than infinity. This is specifically
to avoid denial of service attacks by default. To enable uploads and to
allow them to be of infinite size you simply:</P>
<PRE>
    $CGI::Simple::Standard::POST_MAX = -1;         # infinite size upload
    $CGI::Simple::Standard::$DISABLE_UPLOADS = 0;  # enable uploads</PRE>
<P>Alternatively you can specify the CGI.pm default values as shown above by
specifying the '-default' pragma in your use statement.</P>
<PRE>
    use CGI::Simple::Standard qw( -default ..... );</PRE>
<P>
<H2><A NAME="export">EXPORT</A></H2>
<P>Nothing by default.</P>
<P>Under the '-autoload' pragma the AUTOLOAD subroutine is
exported into the calling namespace. Additional subroutines are only imported
into this namespace if you physically call them. They are installed in the
symbol table the first time you use them to save repeated calls to AUTOLOAD.</P>
<P>If you specifically request a function or group of functions via an EXPORT_TAG
then stubs of these functions are exported into the calling namespace. These
stub functions will be replaced with the real functions only if you actually
call them saving wasted compilation effort.</P>
<P>
<H2><A NAME="function details">FUNCTION DETAILS</A></H2>
<P>This is a wrapper module for CGI::Simple. Virtually all the methods available
in the OO interface are available via the functional interface. Several
method names are aliased to prevent namespace conflicts:</P>
<PRE>
    $q-&gt;delete('foo')   =&gt;  Delete('foo')
    $q-&gt;delete_all      =&gt;  Delete_all() or delete_all()
    $q-&gt;save(\*FH)      =&gt;  save_parameters(\*FH)
    $q-&gt;accept()        =&gt;  Accept()</PRE>
<P>Although you could use the <CODE>new()</CODE> function to genrate new OO CGI::Simple
objects the <CODE>restore_parameters()</CODE> function is a better choice as it operates
like new but on the correct underlying CGI::Simple object for the functional
interface.</P>
<P><CODE>restore_parameters()</CODE> can be used exactly as you might use <CODE>new()</CODE> in that
you can supply arguments to it such as query strings, hashes and file handles
to re-initialize your underlying object.</P>
<PRE>
    $q-&gt;new CGI::Simple()                =&gt; restore_parameters()
    $q-&gt;new CGI::Simple({foo=&gt;'bar'})    =&gt; restore_parameters({foo=&gt;'bar'})
    $q-&gt;new CGI::Simple($query_string)   =&gt; restore_parameters($query_string)
    $q-&gt;new CGI::Simple(\*FH)            =&gt; restore_parameters(\*FH)</PRE>
<P>For full details of the available functions see the CGI::Simple docs. Just
remove the $q-&gt; part and use the method name directly.</P>
<P>
<H2><A NAME="bugs">BUGS</A></H2>
<P>As this is 0.01 there are almost bound to be some.</P>
<P>
<H2><A NAME="author">AUTHOR</A></H2>
<P>Dr James Freeman &lt;<A HREF="mailto:jfreeman@tassie.net.au">jfreeman@tassie.net.au</A>&gt;</P>
<P>This package is free software and is provided ``as is'' without express or
implied warranty. It may be used, redistributed and/or modified under the terms
of the Perl Artistic License (see <A HREF="http://www.perl.com/perl/misc/Artistic.html)">http://www.perl.com/perl/misc/Artistic.html)</A></P>
<P>
<H2><A NAME="credits">CREDITS</A></H2>
<P>The interface and key sections of the CGI::Simple code come from
CGI.pm by Lincoln Stein.</P>
<P>
<H2><A NAME="see also">SEE ALSO</A></H2>
<P><A HREF="#cgi::simple which is the back end for this module">CGI::Simple which is the back end for this module</A>,
<STRONG>CGI.pm by Lincoln Stein</STRONG></P>
<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH=100%>
<TR><TD CLASS=block VALIGN=MIDDLE WIDTH=100% BGCOLOR="#cccccc">
<FONT SIZE=+1><STRONG><P CLASS=block>&nbsp;Standard.pm</P></STRONG></FONT>
</TD></TR>
</TABLE>

</BODY>

</HTML>
